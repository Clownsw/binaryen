;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.

;; Tests for the "1a" form of non-nullable locals. This will likely be the final
;; form in the spec. We test:
;;
;;  * Just printing the module as read from text here. There is no limit on
;;    locals that way: everything is allowed.
;;  * Round-tripping through the binary. In the binary we enforce "1a", so some
;;    locals become nullable.
;;  * Optimizing also enforces "1a".
;;
;; Note: all functions have some extra params added, which look silly. Those
;; prevent the optimization pipeline from merging functions, which would make
;; the results very hard to read.

;; RUN: wasm-opt %s -all             -S -o - | filecheck %s --check-prefix PRINT
;; RUN: wasm-opt %s -all --roundtrip -S -o - | filecheck %s --check-prefix ROUNDTRIP
;; RUN: wasm-opt %s -all -O1         -S -o - | filecheck %s --check-prefix OPTIMIZE

(module
  ;; PRINT:      (type $none_=>_none (func))

  ;; PRINT:      (type $ref|func|_=>_none (func (param (ref func))))

  ;; PRINT:      (type $anyref_=>_i32 (func (param anyref) (result i32)))

  ;; PRINT:      (elem declare func $helper)

  ;; PRINT:      (export "no-uses" (func $no-uses))

  ;; PRINT:      (export "func-scope" (func $func-scope))

  ;; PRINT:      (export "inner-scope" (func $inner-scope))

  ;; PRINT:      (export "func-to-inner" (func $func-to-inner))

  ;; PRINT:      (export "inner-to-func" (func $inner-to-func))

  ;; PRINT:      (export "if-condition" (func $if-condition))

  ;; PRINT:      (export "get-without-set-but-param" (func $get-without-set-but-param))

  ;; PRINT:      (func $no-uses
  ;; PRINT-NEXT:  (local $x (ref func))
  ;; PRINT-NEXT:  (nop)
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (type $none_=>_none (func))

  ;; ROUNDTRIP:      (type $ref|func|_=>_none (func (param (ref func))))

  ;; ROUNDTRIP:      (type $anyref_=>_i32 (func (param anyref) (result i32)))

  ;; ROUNDTRIP:      (elem declare func $helper)

  ;; ROUNDTRIP:      (export "no-uses" (func $no-uses))

  ;; ROUNDTRIP:      (export "func-scope" (func $func-scope))

  ;; ROUNDTRIP:      (export "inner-scope" (func $inner-scope))

  ;; ROUNDTRIP:      (export "func-to-inner" (func $func-to-inner))

  ;; ROUNDTRIP:      (export "inner-to-func" (func $inner-to-func))

  ;; ROUNDTRIP:      (export "if-condition" (func $if-condition))

  ;; ROUNDTRIP:      (export "get-without-set-but-param" (func $get-without-set-but-param))

  ;; ROUNDTRIP:      (func $no-uses
  ;; ROUNDTRIP-NEXT:  (local $x (ref func))
  ;; ROUNDTRIP-NEXT:  (nop)
  ;; ROUNDTRIP-NEXT: )
  ;; OPTIMIZE:      (type $none_=>_none (func))

  ;; OPTIMIZE:      (type $ref|func|_=>_none (func (param (ref func))))

  ;; OPTIMIZE:      (type $anyref_=>_i32 (func (param anyref) (result i32)))

  ;; OPTIMIZE:      (elem declare func $no-uses)

  ;; OPTIMIZE:      (export "no-uses" (func $no-uses))

  ;; OPTIMIZE:      (export "func-scope" (func $no-uses))

  ;; OPTIMIZE:      (export "inner-scope" (func $no-uses))

  ;; OPTIMIZE:      (export "func-to-inner" (func $no-uses))

  ;; OPTIMIZE:      (export "inner-to-func" (func $no-uses))

  ;; OPTIMIZE:      (export "if-condition" (func $if-condition))

  ;; OPTIMIZE:      (export "get-without-set-but-param" (func $get-without-set-but-param))

  ;; OPTIMIZE:      (func $no-uses
  ;; OPTIMIZE-NEXT:  (nop)
  ;; OPTIMIZE-NEXT: )
  (func $no-uses (param i32) (export "no-uses") ;; see note above on param
    ;; A local with no uses validates - no need for changes.
    (local $x (ref func))
  )

  ;; PRINT:      (func $func-scope
  ;; PRINT-NEXT:  (local $x (ref func))
  ;; PRINT-NEXT:  (local.set $x
  ;; PRINT-NEXT:   (ref.func $helper)
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT:  (drop
  ;; PRINT-NEXT:   (local.get $x)
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $func-scope
  ;; ROUNDTRIP-NEXT:  (local $x (ref func))
  ;; ROUNDTRIP-NEXT:  (local.set $x
  ;; ROUNDTRIP-NEXT:   (ref.func $helper)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT:  (drop
  ;; ROUNDTRIP-NEXT:   (local.get $x)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  (func $func-scope (param i64) (export "func-scope")
    ;; a set in the func scope helps a get validate there.
    (local $x (ref func))
    (local.set $x
      (ref.func $helper)
    )
    (drop
      (local.get $x)
    )
  )

  ;; PRINT:      (func $inner-scope
  ;; PRINT-NEXT:  (local $x (ref func))
  ;; PRINT-NEXT:  (block $b
  ;; PRINT-NEXT:   (local.set $x
  ;; PRINT-NEXT:    (ref.func $helper)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:   (drop
  ;; PRINT-NEXT:    (local.get $x)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $inner-scope
  ;; ROUNDTRIP-NEXT:  (local $x (ref func))
  ;; ROUNDTRIP-NEXT:  (local.set $x
  ;; ROUNDTRIP-NEXT:   (ref.func $helper)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT:  (drop
  ;; ROUNDTRIP-NEXT:   (local.get $x)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  (func $inner-scope (param f32) (export "inner-scope")
    ;; a set in an inner scope helps a get validate there.
    (local $x (ref func))
    (block $b
      (local.set $x
        (ref.func $helper)
      )
      (drop
        (local.get $x)
      )
    )
  )

  ;; PRINT:      (func $func-to-inner
  ;; PRINT-NEXT:  (local $x (ref func))
  ;; PRINT-NEXT:  (local.set $x
  ;; PRINT-NEXT:   (ref.func $helper)
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT:  (block $b
  ;; PRINT-NEXT:   (drop
  ;; PRINT-NEXT:    (local.get $x)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $func-to-inner
  ;; ROUNDTRIP-NEXT:  (local $x (ref func))
  ;; ROUNDTRIP-NEXT:  (local.set $x
  ;; ROUNDTRIP-NEXT:   (ref.func $helper)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT:  (block $label$1
  ;; ROUNDTRIP-NEXT:   (drop
  ;; ROUNDTRIP-NEXT:    (local.get $x)
  ;; ROUNDTRIP-NEXT:   )
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  (func $func-to-inner (param f64) (export "func-to-inner")
    ;; a set in an outer scope helps a get validate.
    (local $x (ref func))
    (local.set $x
      (ref.func $helper)
    )
    (block $b
      (drop
        (local.get $x)
      )
    )
  )

  ;; PRINT:      (func $inner-to-func
  ;; PRINT-NEXT:  (local $x funcref)
  ;; PRINT-NEXT:  (block $b
  ;; PRINT-NEXT:   (local.set $x
  ;; PRINT-NEXT:    (ref.func $helper)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT:  (drop
  ;; PRINT-NEXT:   (local.get $x)
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $inner-to-func
  ;; ROUNDTRIP-NEXT:  (local $x funcref)
  ;; ROUNDTRIP-NEXT:  (block $label$1
  ;; ROUNDTRIP-NEXT:   (local.set $x
  ;; ROUNDTRIP-NEXT:    (ref.func $helper)
  ;; ROUNDTRIP-NEXT:   )
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT:  (drop
  ;; ROUNDTRIP-NEXT:   (local.get $x)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  (func $inner-to-func (param i32 i32) (export "inner-to-func")
    ;; a set in an inner scope does *not* help a get validate, but the type is
    ;; nullable so that's ok.
    (local $x (ref null func))
    (block $b
      (local.set $x
        (ref.func $helper)
      )
    )
    (drop
      (local.get $x)
    )
  )

  ;; PRINT:      (func $if-condition
  ;; PRINT-NEXT:  (local $x (ref func))
  ;; PRINT-NEXT:  (if
  ;; PRINT-NEXT:   (call $helper2
  ;; PRINT-NEXT:    (local.tee $x
  ;; PRINT-NEXT:     (ref.func $helper)
  ;; PRINT-NEXT:    )
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:   (drop
  ;; PRINT-NEXT:    (local.get $x)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:   (drop
  ;; PRINT-NEXT:    (local.get $x)
  ;; PRINT-NEXT:   )
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $if-condition
  ;; ROUNDTRIP-NEXT:  (local $x (ref func))
  ;; ROUNDTRIP-NEXT:  (if
  ;; ROUNDTRIP-NEXT:   (call $helper2
  ;; ROUNDTRIP-NEXT:    (local.tee $x
  ;; ROUNDTRIP-NEXT:     (ref.func $helper)
  ;; ROUNDTRIP-NEXT:    )
  ;; ROUNDTRIP-NEXT:   )
  ;; ROUNDTRIP-NEXT:   (drop
  ;; ROUNDTRIP-NEXT:    (local.get $x)
  ;; ROUNDTRIP-NEXT:   )
  ;; ROUNDTRIP-NEXT:   (drop
  ;; ROUNDTRIP-NEXT:    (local.get $x)
  ;; ROUNDTRIP-NEXT:   )
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  ;; OPTIMIZE:      (func $if-condition
  ;; OPTIMIZE-NEXT:  (drop
  ;; OPTIMIZE-NEXT:   (call $helper2
  ;; OPTIMIZE-NEXT:    (ref.func $no-uses)
  ;; OPTIMIZE-NEXT:   )
  ;; OPTIMIZE-NEXT:  )
  ;; OPTIMIZE-NEXT: )
  (func $if-condition (param i64 i64) (export "if-condition")
    (local $x (ref func))
    (if
      (call $helper2
        ;; Tee in the condition is good enough for the arms.
        (local.tee $x
          (ref.func $helper)
        )
      )
      (drop
        (local.get $x)
      )
      (drop
        (local.get $x)
      )
    )
  )

  ;; PRINT:      (func $get-without-set-but-param (param $x (ref func))
  ;; PRINT-NEXT:  (drop
  ;; PRINT-NEXT:   (local.get $x)
  ;; PRINT-NEXT:  )
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $get-without-set-but-param (param $x (ref func))
  ;; ROUNDTRIP-NEXT:  (drop
  ;; ROUNDTRIP-NEXT:   (local.get $x)
  ;; ROUNDTRIP-NEXT:  )
  ;; ROUNDTRIP-NEXT: )
  ;; OPTIMIZE:      (func $get-without-set-but-param (param $0 (ref func))
  ;; OPTIMIZE-NEXT:  (nop)
  ;; OPTIMIZE-NEXT: )
  (func $get-without-set-but-param (param f32 f32) (export "get-without-set-but-param")
    ;; As a parameter, this is ok to get without a set.
    (param $x (ref func))
    (drop
      (local.get $x)
    )
  )

  ;; PRINT:      (func $helper
  ;; PRINT-NEXT:  (nop)
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $helper
  ;; ROUNDTRIP-NEXT:  (nop)
  ;; ROUNDTRIP-NEXT: )
  (func $helper)

  ;; PRINT:      (func $helper2 (param $0 anyref) (result i32)
  ;; PRINT-NEXT:  (unreachable)
  ;; PRINT-NEXT: )
  ;; ROUNDTRIP:      (func $helper2 (param $0 anyref) (result i32)
  ;; ROUNDTRIP-NEXT:  (unreachable)
  ;; ROUNDTRIP-NEXT: )
  ;; OPTIMIZE:      (func $helper2 (param $0 anyref) (result i32)
  ;; OPTIMIZE-NEXT:  (unreachable)
  ;; OPTIMIZE-NEXT: )
  (func $helper2 (param anyref) (result i32)
    (unreachable)
  )
)
