;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s -all --dae -S -o - | filecheck %s
;; RUN: wasm-opt %s -all --dae --nominal -S -o - | filecheck %s --check-prefix NOMNL

;; Similar to dae-gc-refine-return.wast, but with nulls (that is, without
;; anything wrapping the nulls that would prevent us updating their types).

(module
 ;; CHECK:      (type $return_{} (func (result (ref ${}))))
 ;; NOMNL:      (type $return_{} (func_subtype (result (ref ${})) func))
 (type $return_{} (func (result (ref ${}))))

 ;; CHECK:      (type ${} (struct ))

 ;; CHECK:      (type ${i32_f32} (struct (field i32) (field f32)))
 ;; NOMNL:      (type ${} (struct_subtype  data))

 ;; NOMNL:      (type ${i32_f32} (struct_subtype (field i32) (field f32) ${i32}))
 (type ${i32_f32} (struct_subtype (field i32) (field f32) ${i32}))

 ;; CHECK:      (type ${i32_i64} (struct (field i32) (field i64)))
 ;; NOMNL:      (type ${i32_i64} (struct_subtype (field i32) (field i64) ${i32}))
 (type ${i32_i64} (struct_subtype (field i32) (field i64) ${i32}))

 ;; CHECK:      (type ${i32} (struct (field i32)))
 ;; NOMNL:      (type ${i32} (struct_subtype (field i32) ${}))
 (type ${i32} (struct_subtype (field i32) ${}))

 (type ${} (struct))

 (table 1 1 funcref)


 ;; We cannot refine the return type if there is nothing obvious to improve
 ;; it to: a null anyref will leave the function returning anyref.
 ;; CHECK:      (func $refine-return-no-refining (result anyref)
 ;; CHECK-NEXT:  (local $temp anyref)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (call $refine-return-no-refining)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (ref.null any)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $refine-return-no-refining (result anyref)
 ;; NOMNL-NEXT:  (local $temp anyref)
 ;; NOMNL-NEXT:  (local.set $temp
 ;; NOMNL-NEXT:   (call $refine-return-no-refining)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (ref.null any)
 ;; NOMNL-NEXT: )
 (func $refine-return-no-refining (result anyref)
  (local $temp anyref)
  (local.set $temp (call $refine-return-no-refining))

  (ref.null any)
 )

 ;; Refine the return type based on the value flowing out.
 ;; CHECK:      (func $refine-return-flow (result funcref)
 ;; CHECK-NEXT:  (local $temp anyref)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (call $refine-return-flow)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (ref.null func)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $refine-return-flow (result funcref)
 ;; NOMNL-NEXT:  (local $temp anyref)
 ;; NOMNL-NEXT:  (local.set $temp
 ;; NOMNL-NEXT:   (call $refine-return-flow)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (ref.null func)
 ;; NOMNL-NEXT: )
 (func $refine-return-flow (result anyref)
  (local $temp anyref)
  (local.set $temp (call $refine-return-flow))

  (ref.null func)
 )

 ;; Refine the return type based on multiple values.
 ;; CHECK:      (func $refine-return-many (result funcref)
 ;; CHECK-NEXT:  (local $temp anyref)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (call $refine-return-many)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (i32.const 1)
 ;; CHECK-NEXT:   (return
 ;; CHECK-NEXT:    (ref.null func)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (i32.const 2)
 ;; CHECK-NEXT:   (return
 ;; CHECK-NEXT:    (ref.null func)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (ref.null func)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $refine-return-many (result funcref)
 ;; NOMNL-NEXT:  (local $temp anyref)
 ;; NOMNL-NEXT:  (local.set $temp
 ;; NOMNL-NEXT:   (call $refine-return-many)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (if
 ;; NOMNL-NEXT:   (i32.const 1)
 ;; NOMNL-NEXT:   (return
 ;; NOMNL-NEXT:    (ref.null func)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (if
 ;; NOMNL-NEXT:   (i32.const 2)
 ;; NOMNL-NEXT:   (return
 ;; NOMNL-NEXT:    (ref.null func)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (ref.null func)
 ;; NOMNL-NEXT: )
 (func $refine-return-many (result anyref)
  (local $temp anyref)
  (local.set $temp (call $refine-return-many))

  (if
   (i32.const 1)
   (return (ref.null func))
  )
  (if
   (i32.const 2)
   (return (ref.null func))
  )
  (ref.null func)
 )

 ;; CHECK:      (func $refine-return-many-blocked (result anyref)
 ;; CHECK-NEXT:  (local $temp anyref)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (call $refine-return-many-blocked)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (i32.const 1)
 ;; CHECK-NEXT:   (return
 ;; CHECK-NEXT:    (ref.null func)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (i32.const 2)
 ;; CHECK-NEXT:   (return
 ;; CHECK-NEXT:    (ref.null data)
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (ref.null func)
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $refine-return-many-blocked (result anyref)
 ;; NOMNL-NEXT:  (local $temp anyref)
 ;; NOMNL-NEXT:  (local.set $temp
 ;; NOMNL-NEXT:   (call $refine-return-many-blocked)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (if
 ;; NOMNL-NEXT:   (i32.const 1)
 ;; NOMNL-NEXT:   (return
 ;; NOMNL-NEXT:    (ref.null func)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (if
 ;; NOMNL-NEXT:   (i32.const 2)
 ;; NOMNL-NEXT:   (return
 ;; NOMNL-NEXT:    (ref.null data)
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (ref.null func)
 ;; NOMNL-NEXT: )
 (func $refine-return-many-blocked (result anyref)
  (local $temp anyref)
  (local.set $temp (call $refine-return-many-blocked))

  (if
   (i32.const 1)
   (return (ref.null func))
  )
  (if
   (i32.const 2)
   ;; The refined return value is blocked by this return: all we see are various
   ;; nulls here, and their LUB is not useful.
   (return (ref.null data))
  )
  (ref.null func)
 )

 ;; CHECK:      (func $refine-return-many-middle (result (ref null ${i32}))
 ;; CHECK-NEXT:  (local $temp anyref)
 ;; CHECK-NEXT:  (local.set $temp
 ;; CHECK-NEXT:   (call $refine-return-many-middle)
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (if
 ;; CHECK-NEXT:   (i32.const 1)
 ;; CHECK-NEXT:   (return
 ;; CHECK-NEXT:    (ref.null ${i32_i64})
 ;; CHECK-NEXT:   )
 ;; CHECK-NEXT:  )
 ;; CHECK-NEXT:  (ref.null ${i32_f32})
 ;; CHECK-NEXT: )
 ;; NOMNL:      (func $refine-return-many-middle (result (ref null ${i32}))
 ;; NOMNL-NEXT:  (local $temp anyref)
 ;; NOMNL-NEXT:  (local.set $temp
 ;; NOMNL-NEXT:   (call $refine-return-many-middle)
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (if
 ;; NOMNL-NEXT:   (i32.const 1)
 ;; NOMNL-NEXT:   (return
 ;; NOMNL-NEXT:    (ref.null ${i32_i64})
 ;; NOMNL-NEXT:   )
 ;; NOMNL-NEXT:  )
 ;; NOMNL-NEXT:  (ref.null ${i32_f32})
 ;; NOMNL-NEXT: )
 (func $refine-return-many-middle (result anyref)
  (local $temp anyref)
  (local.set $temp (call $refine-return-many-middle))

  ;; Return two different struct types, with an LUB that is not equal to either
  ;; of them.
  (if
   (i32.const 1)
   (return (ref.null ${i32_i64}))
  )
  (ref.null ${i32_f32})
 )

 ;; TODO: new tests for new stuff
)
