;; NOTE: Assertions have been generated by update_lit_checks.py --all-items and should not be edited.
;; RUN: foreach %s %t wasm-opt -all --gufa --nominal -tnh -S -o - | filecheck %s

;; Many of these tests check for us being able to optimize a non-nullable value
;; away, that is, to replace (ref.as_non_null (..)) with an unreachable. We must
;; coerce to non-null in places where the type is nullable, otherwise we will
;; not be able to show any optimizations there, since the optimization is "if
;; the type is declared as non-nullable, but the oracle shows that no actual
;; type is possible there, then that code can never be reached". Note that we
;; also use -tnh to make it possible to remove such a trap.

(module
  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))


  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_ref|$struct| (func_subtype (result (ref $struct)) func))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|any| (func_subtype (result (ref any)) func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $no-non-null (type $none_=>_ref|any|) (result (ref any))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $no-non-null (result (ref any))
    ;; Cast a null to non-null in order to get wasm to validate, but of course
    ;; this will trap at runtime. The possible-types pass will see that no
    ;; actual type can reach the function exit, and will add an unreachable
    ;; here. (Replacing the ref.as with an unreachable is not terribly useful in
    ;; this instance, but it checks that we properly infer things, and in other
    ;; cases replacing with an unreachable can be good.)
    (ref.as_non_null
      (ref.null any)
    )
  )

  ;; CHECK:      (func $nested (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (ref.is_null
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (loop $loop-in
  ;; CHECK-NEXT:      (block
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nested (result i32)
    ;; As above, but add other instructions on the outside, which can also be
    ;; replaced.
    (ref.is_null
      (loop (result (ref func))
        (nop)
        (ref.as_func
          (ref.as_non_null
            (ref.null any)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $yes-non-null (type $none_=>_ref|any|) (result (ref any))
  ;; CHECK-NEXT:  (ref.as_non_null
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $yes-non-null (result (ref any))
    ;; Similar to the above but now there *is* an allocation, and so we have
    ;; nothing to optimize. (The ref.as is redundant, but we leave that for
    ;; other passes, and we keep it in this test to keep the testcase identical
    ;; to the above in all ways except for having a possible type.)
    (ref.as_non_null
      (struct.new $struct)
    )
  )

  ;; CHECK:      (func $breaks (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block $block (result (ref $struct))
  ;; CHECK-NEXT:    (br $block
  ;; CHECK-NEXT:     (struct.new_default $struct)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $breaks
    ;; Check that we notice values sent along breaks. We should optimize
    ;; nothing here.
    (drop
      (block $block (result (ref any))
        (br $block
          (struct.new $struct)
        )
      )
    )
    ;; But here we send a null so we can optimize.
    (drop
      (ref.as_non_null
        (block $block2 (result (ref null any))
          (br $block2
            (ref.null $struct)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $get-nothing (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $get-nothing (result (ref $struct))
    ;; This function returns a non-nullable struct by type, but does not
    ;; actually return a value in practice, and our whole-program analysis
    ;; should pick that up in optimizing the callers.
    (unreachable)
  )

  ;; CHECK:      (func $get-nothing-calls (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (call $get-nothing)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.is_null
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.as_non_null
  ;; CHECK-NEXT:      (block
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (call $get-nothing)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-nothing-calls
    ;; This should be optimized out since the call does not actually return any
    ;; type in practice.
    (drop
      (call $get-nothing)
    )
    ;; Test for the result of such a call reaching another instruction. We do
    ;; not optimize the ref.is_null here, because it returns an i32 (though we
    ;; could in the future infer its value).
    (drop
      (ref.is_null
        (call $get-nothing)
      )
    )
    ;; As above, but an instruction that does return a reference, which we can
    ;; put an unreachable after.
    (drop
      (ref.as_non_null
        (call $get-nothing)
      )
    )
  )

  ;; CHECK:      (func $two-inputs (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (call $get-nothing)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (select (result (ref $struct))
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (call $import)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (select
  ;; CHECK-NEXT:      (block
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (call $get-nothing)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (block
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (call $get-nothing)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (unreachable)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (call $import)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $two-inputs
    ;; As above, but now the outer instruction is a select, and some of the arms
    ;; may have a possible type - we check all 4 permutations. Only in the
    ;; case where both inputs are nothing can we optimize away the select, as
    ;; only then will the select never have anything.
    (drop
      (select (result (ref any))
        (struct.new $struct)
        (call $get-nothing)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (call $get-nothing)
        (struct.new $struct)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (struct.new $struct)
        (struct.new $struct)
        (call $import)
      )
    )
    (drop
      (select (result (ref any))
        (call $get-nothing)
        (call $get-nothing)
        (call $import)
      )
    )
  )

  ;; CHECK:      (func $get-something-flow (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (struct.new_default $struct)
  ;; CHECK-NEXT: )
  (func $get-something-flow (result (ref $struct))
    ;; Return a value by flowing it out.
    (struct.new $struct)
  )

  ;; CHECK:      (func $get-something-return (type $none_=>_ref|$struct|) (result (ref $struct))
  ;; CHECK-NEXT:  (return
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $get-something-return (result (ref $struct))
    ;; Return a value using an explicit return
    (return
      (struct.new $struct)
    )
  )

  ;; CHECK:      (func $call-get-something (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $get-something-flow)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $get-something-return)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-get-something
    ;; In both of these cases a value is actually returned and there is nothing
    ;; to optimize, unlike get-nothing from above.
    (drop
      (call $get-something-flow)
    )
    (drop
      (call $get-something-return)
    )
  )

  ;; CHECK:      (func $locals (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local $y anyref)
  ;; CHECK-NEXT:  (local $z anyref)
  ;; CHECK-NEXT:  (local.tee $x
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (call $get-nothing)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $z
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $locals
    (local $x (ref null any))
    (local $y (ref null any))
    (local $z (ref null any))
    ;; Assign to x from a call that actually will not return anything. We will
    ;; be able to optimize around the call.
    (local.set $x
      (call $get-nothing)
    )
    ;; Never assign to y.
    ;; Assign to z an actual value.
    (local.set $z
      (struct.new $struct)
    )
    ;; Get the 3 locals, to check that we optimize. We can replace x and y with
    ;; a null constant.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $null anyref (ref.null any))
  (global $null (ref null any) (ref.null any))
  ;; CHECK:      (global $something anyref (struct.new_default $struct))
  (global $something (ref null any) (struct.new $struct))

  ;; CHECK:      (global $mut-null (mut anyref) (ref.null any))
  (global $mut-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $mut-something (mut anyref) (ref.null any))
  (global $mut-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $read-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $mut-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $read-globals
    ;; This global has no possible type written to it, so we can optimize it to
    ;; a null. TODO: remove ref.as_non_nulls
    (drop
      (ref.as_non_null
        (global.get $null)
      )
    )
    ;; This global has a possible type, so there is nothing to do.
    (drop
      (ref.as_non_null
        (global.get $something)
      )
    )
    ;; This mutable global has no possible types as we only write a null to it
    ;; in the function later down.
    ;; FIXME: this test is nondeterministic, ref null any/$struct. All nulls are
    ;;        equal, so the first one "wins". We should put the LUB I guess?
    (drop
      (ref.as_non_null
        (global.get $mut-null)
      )
    )
    ;; This function is written a non-null value later down.
    (drop
      (ref.as_non_null
        (global.get $mut-something)
      )
    )
  )

  ;; CHECK:      (func $write-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (global.set $mut-null
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $mut-something
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $write-globals
    (global.set $mut-null
      (ref.null $struct)
    )
    (global.set $mut-something
      (struct.new $struct)
    )
  )
)

;; As above, but now with a chain of globals: A starts with a value, which is
;; copied to B, and then C, and then C is read. We will be able to optimize
;; away *-null (which is where A-null starts with null) but not *-something
;; (wihch is where A-something starts with a value).
(module
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (global $A-null anyref (ref.null any))
  (global $A-null (ref null any) (ref.null any))
  ;; CHECK:      (global $A-something anyref (struct.new_default $struct))
  (global $A-something (ref null any) (struct.new $struct))

  ;; CHECK:      (global $B-null (mut anyref) (ref.null any))
  (global $B-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $B-something (mut anyref) (ref.null any))
  (global $B-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (global $C-null (mut anyref) (ref.null any))
  (global $C-null (mut (ref null any)) (ref.null any))
  ;; CHECK:      (global $C-something (mut anyref) (ref.null any))
  (global $C-something (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $read-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $A-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $B-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (global.get $C-something)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $read-globals
    (drop
      (ref.as_non_null
        (global.get $A-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $A-something)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $B-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $B-something)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $C-null)
      )
    )
    (drop
      (ref.as_non_null
        (global.get $C-something)
      )
    )
  )

  ;; CHECK:      (func $write-globals (type $none_=>_none)
  ;; CHECK-NEXT:  (global.set $B-null
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $C-null
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $B-something
  ;; CHECK-NEXT:   (global.get $A-something)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $C-something
  ;; CHECK-NEXT:   (global.get $B-something)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $write-globals
    (global.set $B-null
      (global.get $A-null)
    )
    (global.set $C-null
      (global.get $B-null)
    )
    (global.set $B-something
      (global.get $A-something)
    )
    (global.set $C-something
      (global.get $B-something)
    )
  )
)

(module
  ;; CHECK:      (type $ref|any|_=>_ref|any| (func_subtype (param (ref any)) (result (ref any)) func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (type $ref|any|_ref|any|_ref|any|_=>_none (func_subtype (param (ref any) (ref any) (ref any)) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $never-called (type $ref|any|_=>_ref|any|) (param $x (ref any)) (result (ref any))
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $never-called (param $x (ref any)) (result (ref any))
    ;; This function is never called, so this non-nullable parameter cannot
    ;; contain any actual value, and we can optimize it away.
    (local.get $x)
  )

  ;; CHECK:      (func $recursion (type $ref|any|_=>_ref|any|) (param $x (ref any)) (result (ref any))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (call $recursion
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $recursion (param $x (ref any)) (result (ref any))
    ;; This function calls itself recursively. That forms a loop, but still, no
    ;; type is possible here, so we can optimize away.
    (call $recursion
      (local.get $x)
    )
  )

  ;; CHECK:      (func $called (type $ref|any|_ref|any|_ref|any|_=>_none) (param $x (ref any)) (param $y (ref any)) (param $z (ref any))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $called (param $x (ref any)) (param $y (ref any)) (param $z (ref any))
    ;; This function *is* called, with possible types in the first and last
    ;; parameter but not the middle, which can be optimized out.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
  )

  ;; CHECK:      (func $call-called (type $none_=>_none)
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $called
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $call-called
    (call $called
      (struct.new $struct)
      (ref.as_non_null
        (ref.null any)
      )
      (ref.as_non_null
        (ref.null any)
      )
    )
    (call $called
      (ref.as_non_null
        (ref.null any)
      )
      (ref.as_non_null
        (ref.null any)
      )
      (struct.new $struct)
    )
  )
)

;; As above, but using indirect calls.
(module
  ;; CHECK:      (type $struct (struct_subtype  data))

  ;; CHECK:      (type $two-params (func_subtype (param (ref $struct) (ref $struct)) func))
  (type $two-params (func (param (ref $struct)) (param (ref $struct))))

  ;; CHECK:      (type $three-params (func_subtype (param (ref $struct) (ref $struct) (ref $struct)) func))
  (type $three-params (func (param (ref $struct)) (param (ref $struct)) (param (ref $struct))))

  (type $struct (struct))

  (table 10 funcref)

  (elem (i32.const 0) funcref
    (ref.func $func-2params-a)
    (ref.func $func-2params-b)
    (ref.func $func-3params)
  )

  ;; CHECK:      (table $0 10 funcref)

  ;; CHECK:      (elem (i32.const 0) $func-2params-a $func-2params-b $func-3params)

  ;; CHECK:      (export "export-so-params-are-live" (func $func-2params-a))

  ;; CHECK:      (export "export-so-params-are-live-b" (func $func-2params-b))

  ;; CHECK:      (export "export-so-params-are-live-c" (func $func-3params))

  ;; CHECK:      (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $two-params)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-a (export "export-so-params-are-live") (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    ;; (export this function so that the optimizer realizes values can arrive
    ;; in the params; otherwise without a call it will see them as unreachable)
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    ;; Send a value only to the second param.
    (call_indirect (type $two-params)
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (i32.const 0)
    )
  )

  ;; CHECK:      (func $func-2params-b (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-b (export "export-so-params-are-live-b") (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    ;; Another function with the same signature as before, which we should
    ;; optimize in the same way.
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
  )

  ;; CHECK:      (func $func-3params (type $three-params) (param $x (ref $struct)) (param $y (ref $struct)) (param $z (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $z)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $three-params)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_indirect $0 (type $three-params)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-3params (export "export-so-params-are-live-c") (type $three-params) (param $x (ref $struct)) (param $y (ref $struct)) (param $z (ref $struct))
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    (drop
      (local.get $z)
    )
    ;; Send a value only to the first and third param. Do so in two separate
    ;; calls.
    (call_indirect (type $three-params)
      (struct.new $struct)
      (ref.as_non_null
        (ref.null $struct)
      )
      (ref.as_non_null
        (ref.null $struct)
      )
      (i32.const 0)
    )
    (call_indirect (type $three-params)
      (ref.as_non_null
        (ref.null $struct)
      )
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (i32.const 0)
    )
  )
)

;; As above, but using call_ref.
(module
  ;; CHECK:      (type $struct (struct_subtype  data))

  ;; CHECK:      (type $two-params (func_subtype (param (ref $struct) (ref $struct)) func))
  (type $two-params (func (param (ref $struct)) (param (ref $struct))))

  (type $struct (struct))

  ;; CHECK:      (elem declare func $func-2params-a)

  ;; CHECK:      (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (local.get $y)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call_ref
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:   (ref.func $func-2params-a)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func-2params-a (type $two-params) (param $x (ref $struct)) (param $y (ref $struct))
    (drop
      (local.get $x)
    )
    (drop
      (local.get $y)
    )
    ;; Send a value only to the second param.
    (call_ref
      (ref.as_non_null
        (ref.null $struct)
      )
      (struct.new $struct)
      (ref.func $func-2params-a)
    )
  )
)

;; Array creation.
(module
  ;; CHECK:      (type $vector (array_subtype (mut f64) data))
  (type $vector (array (mut f64)))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $arrays (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.new $vector
  ;; CHECK-NEXT:     (f64.const 3.14159)
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.new_default $vector
  ;; CHECK-NEXT:     (i32.const 100)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.init_static $vector
  ;; CHECK-NEXT:     (f64.const 1.1)
  ;; CHECK-NEXT:     (f64.const 2.2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $arrays
    (drop
      (ref.as_non_null
        (array.new $vector
          (f64.const 3.14159)
          (i32.const 1)
        )
      )
    )
    (drop
      (ref.as_non_null
        (array.new_default $vector
          (i32.const 100)
        )
      )
    )
    (drop
      (ref.as_non_null
        (array.init_static $vector
          (f64.const 1.1)
          (f64.const 2.2)
        )
      )
    )
    ;; In the last case we have no possible type and can optimize.
    (drop
      (ref.as_non_null
        (ref.null $vector)
      )
    )
  )
)

;; Struct fields.
(module
  ;; CHECK:      (type $parent (struct_subtype (field (mut (ref null $struct))) data))

  ;; CHECK:      (type $child (struct_subtype (field (mut (ref null $struct))) (field (mut (ref null $struct))) $parent))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct_subtype data))
  (type $parent (struct_subtype (field (mut (ref null $struct))) data))
  (type $child (struct_subtype (field (mut (ref null $struct))) (field (mut (ref null $struct))) $parent))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $child 0
  ;; CHECK-NEXT:     (local.get $child)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref null $struct))
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $child 1
  ;; CHECK-NEXT:        (local.get $child)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null $struct)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref null $struct))
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $parent 0
  ;; CHECK-NEXT:        (local.get $parent)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null $struct)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    ;; We create a child with a value in the first field and nothing in the
    ;; second. Getting the first field should not be optimized as if it
    ;; contains nothing, so the struct.get will remain here.
    (local.set $child
      (struct.new $child
        (struct.new $struct)
        (ref.null $struct)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $child 0
          (local.get $child)
        )
      )
    )
    ;; Exactly the same but get field 1. This time we can optimize away the
    ;; struct.get.
    (local.set $child
      (struct.new $child
        (struct.new $struct)
        (ref.null $struct)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $child 1
          (local.get $child)
        )
      )
    )
    ;; Create a parent with nothing. The child wrote to the shared field, but
    ;; using precise type info we can infer that the get can be optimized out.
    (local.set $parent
      (struct.new $parent
        (ref.null $struct)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $parent 0
          (local.get $parent)
        )
      )
    )
    ;; A null is easy to optimize.
    (drop
      (struct.get $parent 0
        (ref.null $parent)
      )
    )
  )

  ;; CHECK:      (func $nulls (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.null $parent)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block (result anyref)
  ;; CHECK-NEXT:      (br $block
  ;; CHECK-NEXT:       (ref.null any)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref null $parent))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block0 (result (ref null $child))
  ;; CHECK-NEXT:      (br $block0
  ;; CHECK-NEXT:       (ref.null $child)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null $parent)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref null $child))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block $block1 (result (ref null $child))
  ;; CHECK-NEXT:      (br $block1
  ;; CHECK-NEXT:       (block (result (ref null $child))
  ;; CHECK-NEXT:        (drop
  ;; CHECK-NEXT:         (ref.cast_static $child
  ;; CHECK-NEXT:          (ref.null $parent)
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (ref.null $child)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null $child)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $nulls
    ;; Leave null constants alone.
    (drop
      (ref.null $parent)
    )
    ;; Send a null to the block, which is the only value exiting, so we can
    ;; optimize here.
    (drop
      (block $block (result (ref null any))
        (br $block
          (ref.null any)
        )
        (unreachable)
      )
    )
    ;; Send a more specific type. We should emit a valid null constant.
    (drop
      (block $block (result (ref null $parent))
        (br $block
          (ref.null $child)
        )
        (unreachable)
      )
    )
    ;; Send a less specific type, via a cast. But all nulls are identical and
    ;; ref.cast passes nulls through, so this is ok.
    (drop
      (block $block (result (ref null $child))
        (br $block
          (ref.cast_static $child
            (ref.null $parent)
          )
        )
        (unreachable)
      )
    )
    ;; TODO: similar tests with non-null values.
  )
)

;; Default values in struct fields.
(module
  (type $A (struct_subtype (field i32) data))
  (type $B (struct_subtype (field i32) data))
  (type $C (struct_subtype (field i32) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; Create a struct with default values. We can propagate a 0 to the get.
    (drop
      (struct.get $A 0
        (struct.new_default $A)
      )
    )
    ;; Allocate with a non-default value, that can also be propagated.
    (drop
      (struct.get $B 0
        (struct.new $B
          (i32.const 1)
        )
      )
    )
    ;; Never allocate, so no value is possible.
    (drop
      (struct.get $C 0
        (ref.null $C)
      )
    )
  )
)

;; As above, but with the writes to the parent and child partially flipped on
;; the shared field (see below).
(module
  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct_subtype data))
  ;; CHECK:      (type $parent (struct_subtype (field (mut (ref null $struct))) data))
  (type $parent (struct_subtype (field (mut (ref null $struct))) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut (ref null $struct))) (field i32) $parent))
  (type $child (struct_subtype (field (mut (ref null $struct))) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (struct.new_default $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $parent 0
  ;; CHECK-NEXT:     (local.get $parent)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result (ref null $struct))
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (struct.get $child 0
  ;; CHECK-NEXT:        (local.get $child)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null $struct)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    ;; Allocate when writing to the parent's field. We cannot
    ;; optimize here.
    (local.set $parent
      (struct.new $parent
        (struct.new $struct)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $parent 0
          (local.get $parent)
        )
      )
    )
    ;; The child writes nothing to the first field. We can see that there is no
    ;; value possible and optimize away the get.
    (local.set $child
      (struct.new $child
        (ref.null $struct)
        (i32.const 0)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $child 0
          (local.get $child)
        )
      )
    )
  )
)

;; Write to the parent and the child and read from the child.
(module
  ;; CHECK:      (type $parent (struct_subtype (field (mut i32)) data))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $parent)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $child
  ;; CHECK-NEXT:   (struct.new $child
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 1
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 30)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    ;; This can be optimized to 10. The child also sets this field, but the
    ;; reference in the local $parent can only be a $parent and nothing else.
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    (local.set $child
      (struct.new $child
        ;; The value here conflicts with the parent's for this field, but the
        ;; local $child can only contain a $child and nothing else, so we can
        ;; optimize the get below us.
        (i32.const 20)
        (i32.const 30)
      )
    )
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
    ;; This get aliases nothing but 30, so we can optimize.
    (drop
      (struct.get $child 1
        (local.get $child)
      )
    )
  )
)

;; As above, but the $parent local can now contain a child too.
(module
  ;; CHECK:      (type $parent (struct_subtype (field (mut i32)) data))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $parent 0
  ;; CHECK-NEXT:    (local.get $parent)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (local.tee $child
  ;; CHECK-NEXT:    (struct.new $child
  ;; CHECK-NEXT:     (i32.const 20)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 20)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    ;; This get cannot be optimized because below us because the local is
    ;; written a child, below. So the local $parent can refer to either one,
    ;; and they disagree on the aliased value.
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    (local.set $parent
      (local.tee $child
        (struct.new $child
          (i32.const 20)
          (i32.const 30)
        )
      )
    )
    ;; But this one can be optimized as it can only contain a child.
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
  )
)

;; As above, but now the parent and child happen to agree on the aliased value.
(module
  ;; CHECK:      (type $parent (struct_subtype (field (mut i32)) data))
  (type $parent (struct_subtype (field (mut i32)) data))
  ;; CHECK:      (type $child (struct_subtype (field (mut i32)) (field i32) $parent))
  (type $child (struct_subtype (field (mut i32)) (field i32) $parent))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $child (ref null $child))
  ;; CHECK-NEXT:  (local $parent (ref null $parent))
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (struct.new $parent
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $parent 0
  ;; CHECK-NEXT:      (local.get $parent)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $parent
  ;; CHECK-NEXT:   (local.tee $child
  ;; CHECK-NEXT:    (struct.new $child
  ;; CHECK-NEXT:     (i32.const 10)
  ;; CHECK-NEXT:     (i32.const 30)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $child 0
  ;; CHECK-NEXT:      (local.get $child)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    (local $child (ref null $child))
    (local $parent (ref null $parent))
    (local.set $parent
      (struct.new $parent
        (i32.const 10)
      )
    )
    (drop
      (struct.get $parent 0
        (local.get $parent)
      )
    )
    (local.set $parent
      (local.tee $child
        (struct.new $child
          (i32.const 10) ;; This is 10, like above, so we can optimize the get
                         ;; before us.
          (i32.const 30)
        )
      )
    )
    (drop
      (struct.get $child 0
        (local.get $child)
      )
    )
  )
)

;; Arrays get/set
(module
  (type $nothing (array_subtype (mut (ref null any)) data))

  ;; CHECK:      (type $null (array_subtype (mut anyref) data))
  (type $null (array_subtype (mut (ref null any)) data))

  ;; CHECK:      (type $something (array_subtype (mut anyref) data))
  (type $something (array_subtype (mut (ref null any)) data))

  (type $something-child (array_subtype (mut (ref null any)) $something))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.set $null
  ;; CHECK-NEXT:   (array.new_default $null
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block (result anyref)
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (array.get $null
  ;; CHECK-NEXT:        (array.new_default $null
  ;; CHECK-NEXT:         (i32.const 10)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (i32.const 0)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (ref.null any)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.set $something
  ;; CHECK-NEXT:   (array.new_default $something
  ;; CHECK-NEXT:    (i32.const 10)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (array.get $something
  ;; CHECK-NEXT:     (array.new_default $something
  ;; CHECK-NEXT:      (i32.const 10)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (block
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:     (unreachable)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; Write nothing to this array, so we can optimize to an unreachable.
    (drop
      (array.get $nothing
        (ref.null $nothing)
        (i32.const 0)
      )
    )
    ;; Write a null to this array. Again, we can optimize.
    (array.set $null
      (array.new_default $null
        (i32.const 10)
      )
      (i32.const 0)
      (ref.null any)
    )
    (drop
      (ref.as_non_null
        (array.get $null
          (array.new_default $null
            (i32.const 10)
          )
          (i32.const 0)
        )
      )
    )
    ;; In $something we do actually write a value.
    (array.set $something
      (array.new_default $something
        (i32.const 10)
      )
      (i32.const 0)
      (struct.new $struct)
    )
    (drop
      (ref.as_non_null
        (array.get $something
          (array.new_default $something
            (i32.const 10)
          )
          (i32.const 0)
        )
      )
    )
    ;; $something-child has nothing written to it, but it's parent does. Still,
    ;; no $something-child exists so we know this will trap.
    ;; do not optimize (but a better analysis might improve things).
    (drop
      (ref.as_non_null
        (array.get $something-child
          (ref.cast_static $something-child
            (array.new_default $something
              (i32.const 10)
            )
          )
          (i32.const 0)
        )
      )
    )
  )
)

;; A big chain, from an allocation that passes through many locations along the
;; way before it is used. Nothing here can be optimized.
(module
  ;; CHECK:      (type $storage (struct_subtype (field (mut anyref)) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  (type $storage (struct (field (mut (ref null any)))))

  ;; CHECK:      (type $anyref_=>_anyref (func_subtype (param anyref) (result anyref) func))

  ;; CHECK:      (global $x (mut anyref) (ref.null any))
  (global $x (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $x
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $storage 0
  ;; CHECK-NEXT:     (struct.new $storage
  ;; CHECK-NEXT:      (call $pass-through
  ;; CHECK-NEXT:       (global.get $x)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo
    (local $x (ref null any))
    ;; Pass it through a local.
    (local.set $x
      (struct.new $struct)
    )
    ;; Pass it through a global.
    (global.set $x
      (local.get $x)
    )
    ;; Pass it through a call, then write it to a struct, then read it from
    ;; there, and coerce to non-null to allow us to optimize.
    (drop
      (ref.as_non_null
        (struct.get $storage 0
          (struct.new $storage
            (call $pass-through
              (global.get $x)
            )
          )
        )
      )
    )
  )

  ;; CHECK:      (func $pass-through (type $anyref_=>_anyref) (param $x anyref) (result anyref)
  ;; CHECK-NEXT:  (local.get $x)
  ;; CHECK-NEXT: )
  (func $pass-through (param $x (ref null any)) (result (ref null any))
    (local.get $x)
  )
)

;; As above, but the chain is turned into a loop, replacing the initial
;; allocation with a get from the end. We can optimize such cycles.
(module
  (type $struct (struct))

  ;; CHECK:      (type $storage (struct_subtype (field (mut anyref)) data))
  (type $storage (struct (field (mut (ref null any)))))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $anyref_=>_anyref (func_subtype (param anyref) (result anyref) func))

  ;; CHECK:      (global $x (mut anyref) (ref.null any))
  (global $x (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $storage 0
  ;; CHECK-NEXT:      (struct.new $storage
  ;; CHECK-NEXT:       (block (result anyref)
  ;; CHECK-NEXT:        (drop
  ;; CHECK-NEXT:         (call $pass-through
  ;; CHECK-NEXT:          (ref.null any)
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:        (ref.null any)
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $x
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.as_non_null
  ;; CHECK-NEXT:      (block (result anyref)
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (struct.get $storage 0
  ;; CHECK-NEXT:         (struct.new $storage
  ;; CHECK-NEXT:          (block (result anyref)
  ;; CHECK-NEXT:           (drop
  ;; CHECK-NEXT:            (call $pass-through
  ;; CHECK-NEXT:             (ref.null any)
  ;; CHECK-NEXT:            )
  ;; CHECK-NEXT:           )
  ;; CHECK-NEXT:           (ref.null any)
  ;; CHECK-NEXT:          )
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (ref.null any)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo
    (local $x (ref null any))
    (local.set $x
      ;; Replace the allocation here with a read from the $storage struct, which
      ;; is written lower down, so this forms a loop, effectively.
      (struct.get $storage 0
        (struct.new $storage
          (call $pass-through
            (global.get $x)
          )
        )
      )
    )
    (global.set $x
      (local.get $x)
    )
    (drop
      (ref.as_non_null
        (struct.get $storage 0
          (struct.new $storage
            (call $pass-through
              (global.get $x)
            )
          )
        )
      )
    )
  )

  ;; CHECK:      (func $pass-through (type $anyref_=>_anyref) (param $x anyref) (result anyref)
  ;; CHECK-NEXT:  (ref.null any)
  ;; CHECK-NEXT: )
  (func $pass-through (param $x (ref null any)) (result (ref null any))
    (local.get $x)
  )
)

;; A single long chain as above, but now we break the chain in the middle, which
;; we pick up on and optimize at the end.
(module
  ;; CHECK:      (type $storage (struct_subtype (field (mut anyref)) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  (type $storage (struct (field (mut (ref null any)))))

  ;; CHECK:      (type $anyref_=>_anyref (func_subtype (param anyref) (result anyref) func))

  ;; CHECK:      (global $x (mut anyref) (ref.null any))
  (global $x (mut (ref null any)) (ref.null any))

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (global.set $x
  ;; CHECK-NEXT:   (ref.null any)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.as_non_null
  ;; CHECK-NEXT:      (block (result anyref)
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (struct.get $storage 0
  ;; CHECK-NEXT:         (struct.new $storage
  ;; CHECK-NEXT:          (block (result anyref)
  ;; CHECK-NEXT:           (drop
  ;; CHECK-NEXT:            (call $pass-through
  ;; CHECK-NEXT:             (ref.null any)
  ;; CHECK-NEXT:            )
  ;; CHECK-NEXT:           )
  ;; CHECK-NEXT:           (ref.null any)
  ;; CHECK-NEXT:          )
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (ref.null any)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo
    (local $x (ref null any))
    (local.set $x
      (struct.new $struct)
    )
    ;; The only difference from above is that we break the chain by changing the
    ;; global operation here, writing a null instead of the local $x.
    (global.set $x
      (ref.null any)
    )
    (drop
      (ref.as_non_null
        (struct.get $storage 0
          (struct.new $storage
            (call $pass-through
              (global.get $x)
            )
          )
        )
      )
    )
  )

  ;; CHECK:      (func $pass-through (type $anyref_=>_anyref) (param $x anyref) (result anyref)
  ;; CHECK-NEXT:  (ref.null any)
  ;; CHECK-NEXT: )
  (func $pass-through (param $x (ref null any)) (result (ref null any))
    (local.get $x)
  )
)

;; Exceptions.
(module
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $anyref_=>_none (func_subtype (param anyref) func))

  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (tag $nothing (param anyref))
  (tag $nothing (param (ref null any)))

  ;; CHECK:      (tag $something (param anyref))
  (tag $something (param (ref null any)))

  ;; CHECK:      (tag $empty (param))
  (tag $empty (param))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $0 anyref)
  ;; CHECK-NEXT:  (throw $nothing
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $nothing
  ;; CHECK-NEXT:    (local.set $0
  ;; CHECK-NEXT:     (pop anyref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (ref.as_non_null
  ;; CHECK-NEXT:        (block (result anyref)
  ;; CHECK-NEXT:         (drop
  ;; CHECK-NEXT:          (local.get $0)
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:         (ref.null any)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (throw $something
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try0
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $something
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.as_non_null
  ;; CHECK-NEXT:      (pop anyref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; This tag receives no actual value, so we can optimize the pop of it,
    ;; later down.
    (throw $nothing
      (ref.null $struct)
    )
    (try
      (do)
      (catch $nothing
        (drop
          (ref.as_non_null
            (pop (ref null any))
          )
        )
      )
    )
    ;; This tag cannot be optimized as we send it something.
    (throw $something
      (struct.new $struct)
    )
    (try
      (do)
      (catch $something
        (drop
          (ref.as_non_null
            (pop (ref null any))
          )
        )
      )
    )
  )

  ;; CHECK:      (func $empty-tag (type $none_=>_none)
  ;; CHECK-NEXT:  (try $label$3
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $empty
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $empty-tag
    ;; Check we do not error on catching an empty tag.
    (try $label$3
      (do
        (nop)
      )
      (catch $empty
        (nop)
      )
    )
  )

  ;; CHECK:      (func $try-results (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (try $try (result i32)
  ;; CHECK-NEXT:      (do
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (catch $empty
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (catch_all
  ;; CHECK-NEXT:       (i32.const 0)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (try $try1 (result i32)
  ;; CHECK-NEXT:    (do
  ;; CHECK-NEXT:     (i32.const 42)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch $empty
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch_all
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (try $try2 (result i32)
  ;; CHECK-NEXT:    (do
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch $empty
  ;; CHECK-NEXT:     (i32.const 42)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch_all
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (try $try3 (result i32)
  ;; CHECK-NEXT:    (do
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch $empty
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (catch_all
  ;; CHECK-NEXT:     (i32.const 42)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $try-results
    ;; If all values flowing out are identical, we can optimize.
    (drop
      (try (result i32)
        (do
          (i32.const 0)
        )
        (catch $empty
          (i32.const 0)
        )
        (catch_all
          (i32.const 0)
        )
      )
    )
    ;; If any of the values is changed, we cannot.
    (drop
      (try (result i32)
        (do
          (i32.const 42)
        )
        (catch $empty
          (i32.const 0)
        )
        (catch_all
          (i32.const 0)
        )
      )
    )
    (drop
      (try (result i32)
        (do
          (i32.const 0)
        )
        (catch $empty
          (i32.const 42)
        )
        (catch_all
          (i32.const 0)
        )
      )
    )
    (drop
      (try (result i32)
        (do
          (i32.const 0)
        )
        (catch $empty
          (i32.const 0)
        )
        (catch_all
          (i32.const 42)
        )
      )
    )
  )
)

;; Exceptions with a tuple
(module
  ;; CHECK:      (type $struct (struct_subtype  data))
  (type $struct (struct))

  ;; CHECK:      (type $anyref_anyref_=>_none (func_subtype (param anyref anyref) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (tag $tag (param anyref anyref))
  (tag $tag (param (ref null any)) (param (ref null any)))

  ;; CHECK:      (func $func (type $none_=>_none)
  ;; CHECK-NEXT:  (local $0 (anyref anyref))
  ;; CHECK-NEXT:  (throw $tag
  ;; CHECK-NEXT:   (ref.null $struct)
  ;; CHECK-NEXT:   (struct.new_default $struct)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (local.set $0
  ;; CHECK-NEXT:     (pop anyref anyref)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (block
  ;; CHECK-NEXT:      (drop
  ;; CHECK-NEXT:       (ref.as_non_null
  ;; CHECK-NEXT:        (block (result anyref)
  ;; CHECK-NEXT:         (drop
  ;; CHECK-NEXT:          (tuple.extract 0
  ;; CHECK-NEXT:           (local.get $0)
  ;; CHECK-NEXT:          )
  ;; CHECK-NEXT:         )
  ;; CHECK-NEXT:         (ref.null any)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:      (unreachable)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (try $try0
  ;; CHECK-NEXT:   (do
  ;; CHECK-NEXT:    (nop)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (catch $tag
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.as_non_null
  ;; CHECK-NEXT:      (tuple.extract 1
  ;; CHECK-NEXT:       (pop anyref anyref)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $func
    ;; This tag receives no actual value in the first parameter
    (throw $tag
      (ref.null $struct)
      (struct.new $struct)
    )
    ;; Catch the first, which we can optimize.
    (try
      (do)
      (catch $tag
        (drop
          (ref.as_non_null
            (tuple.extract 0
              (pop (ref null any) (ref null any))
            )
          )
        )
      )
    )
    ;; Catch the second, which we cannot optimize.
    (try
      (do)
      (catch $tag
        (drop
          (ref.as_non_null
            (tuple.extract 1
              (pop (ref null any) (ref null any))
            )
          )
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type ${} (struct_subtype  data))
  (type ${} (struct_subtype data))

  ;; CHECK:      (type $none_=>_ref|${}| (func_subtype (result (ref ${})) func))

  ;; CHECK:      (func $func (type $none_=>_ref|${}|) (result (ref ${}))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block $block (result (ref ${}))
  ;; CHECK-NEXT:    (br_on_non_null $block
  ;; CHECK-NEXT:     (ref.null ${})
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (unreachable)
  ;; CHECK-NEXT: )
  (func $func (result (ref ${}))
    ;; This block has no possible types, so it can be removed in principle, but
    ;; we would need to remove the br to it as well, which we currently don't
    ;; (we hope other passes would help out), so leave it, but add an
    ;; unreachable on the outside (which would help other passes).
    (block $block (result (ref ${}))
      (br_on_non_null $block
        (ref.null ${})
      )
      (unreachable)
    )
  )
)

(module
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $A (struct_subtype (field i32) data))
  (type $A (struct_subtype (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field i64) data))
  (type $B (struct_subtype (field i64) data))
  ;; CHECK:      (type $C (struct_subtype (field f32) data))
  (type $C (struct_subtype (field f32) data))
  ;; CHECK:      (type $D (struct_subtype (field f64) data))
  (type $D (struct_subtype (field f64) data))

  ;; CHECK:      (func $many-types (type $none_=>_none)
  ;; CHECK-NEXT:  (local $x anyref)
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new $A
  ;; CHECK-NEXT:    (i32.const 0)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new $B
  ;; CHECK-NEXT:    (i64.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new $C
  ;; CHECK-NEXT:    (f32.const 2)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $x
  ;; CHECK-NEXT:   (struct.new $D
  ;; CHECK-NEXT:    (f64.const 3)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (local.get $x)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $many-types
    (local $x (ref null any))
    ;; Write 4 different types into $x. That should not confuse us, even if just
    ;; one is enough to prevent opts.
    (local.set $x
      (struct.new $A
        (i32.const 0)
      )
    )
    (local.set $x
      (struct.new $B
        (i64.const 1)
      )
    )
    (local.set $x
      (struct.new $C
        (f32.const 2)
      )
    )
    (local.set $x
      (struct.new $D
        (f64.const 3)
      )
    )
    (drop
      (ref.as_non_null
        (local.get $x)
      )
    )
  )
)

;; Test a vtable-like pattern. This tests ref.func values flowing into struct
;; locations being properly noticed.
(module
  ;; CHECK:      (type $vtable-A (struct_subtype (field funcref) (field funcref) (field funcref) data))
  (type $vtable-A (struct_subtype (field (ref null func)) (field (ref null func)) (field (ref null func)) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (global $global-A (ref $vtable-A) (struct.new $vtable-A
  ;; CHECK-NEXT:  (ref.func $foo)
  ;; CHECK-NEXT:  (ref.null func)
  ;; CHECK-NEXT:  (ref.func $foo)
  ;; CHECK-NEXT: ))
  (global $global-A (ref $vtable-A)
    (struct.new $vtable-A
      (ref.func $foo)
      (ref.null func)
      (ref.func $foo)
    )
  )

  ;; CHECK:      (elem declare func $test)

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $vtable-A 0
  ;; CHECK-NEXT:     (global.get $global-A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.new $vtable-A
  ;; CHECK-NEXT:    (ref.null func)
  ;; CHECK-NEXT:    (ref.null func)
  ;; CHECK-NEXT:    (ref.func $test)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (struct.get $vtable-A 2
  ;; CHECK-NEXT:     (global.get $global-A)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The first item here contains a fixed value (ref.func $foo) which we can
    ;; apply.
    (drop
      (ref.as_non_null
        (struct.get $vtable-A 0
          (global.get $global-A)
        )
      )
    )
    ;; The second item here contains a null, so we can optimize away the
    ;; ref.as_non_null.
    (drop
      (ref.as_non_null
        (struct.get $vtable-A 1
          (global.get $global-A)
        )
      )
    )
    ;; The third item has more than one possible value, which we add with
    ;; another struct.new here, so we cannot optimize away the struct.get or
    ;; the ref.as_non_null
    (drop
      (struct.new $vtable-A
        (ref.null func)
        (ref.null func)
        (ref.func $test)
      )
    )
    (drop
      (ref.as_non_null
        (struct.get $vtable-A 2
          (global.get $global-A)
        )
      )
    )
  )

  ;; CHECK:      (func $foo (type $none_=>_none)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $foo)
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $ref (ref null $struct))
  ;; CHECK-NEXT:  (local.set $ref
  ;; CHECK-NEXT:   (block $block (result (ref $struct))
  ;; CHECK-NEXT:    (block $block0 (result (ref $struct))
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (i32.const 42)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (struct.get $struct 0
  ;; CHECK-NEXT:      (local.get $ref)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (i32.const 42)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $ref (ref null $struct))
    ;; Regression test for an assertion firing in this case. We should properly
    ;; handle the multiple intermediate blocks here, allowing us to optimize the
    ;; get below to a 42.
    (local.set $ref
      (block (result (ref $struct))
        (block (result (ref $struct))
          (struct.new $struct
            (i32.const 42)
          )
        )
      )
    )
    (drop
      (struct.get $struct 0
        (local.get $ref)
      )
    )
  )
)

(module
  ;; CHECK:      (type $struct (struct_subtype (field i32) data))
  (type $struct (struct_subtype (field i32) data))
  ;; CHECK:      (type $substruct (struct_subtype (field i32) (field i32) $struct))
  (type $substruct (struct_subtype (field i32) (field i32) $struct))
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $subsubstruct (struct_subtype (field i32) (field i32) (field i32) $substruct))
  (type $subsubstruct (struct_subtype (field i32) (field i32) (field i32) $substruct))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (elem declare func $test)

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (unreachable)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.cast_static $substruct
  ;; CHECK-NEXT:    (struct.new $substruct
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.cast_static $substruct
  ;; CHECK-NEXT:    (struct.new $subsubstruct
  ;; CHECK-NEXT:     (i32.const 3)
  ;; CHECK-NEXT:     (i32.const 4)
  ;; CHECK-NEXT:     (i32.const 5)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.cast_static $struct
  ;; CHECK-NEXT:    (struct.new $struct
  ;; CHECK-NEXT:     (i32.const 6)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; The cast here will fail, and the ref.cast allows nothing through.
    (drop
      (ref.cast_static $substruct
        (struct.new $struct
          (i32.const 0)
        )
      )
    )
    ;; This cast will succeed, and we can optimize in principle, but atm we
    ;; lack a cone type so we do not see that only $substruct is possible, and
    ;; we make no changes here.
    (drop
      (ref.cast_static $substruct
        (struct.new $substruct
          (i32.const 1)
          (i32.const 2)
        )
      )
    )
    ;; This cast of a subtype will also succeed. As above, we can make no
    ;; changes atm.
    (drop
      (ref.cast_static $substruct
        (struct.new $subsubstruct
          (i32.const 3)
          (i32.const 4)
          (i32.const 5)
        )
      )
    )
    ;; All operations on the same struct now. As above, we can make no changes
    ;; atm.
    (drop
      (ref.cast_static $struct
        (struct.new $struct
          (i32.const 6)
        )
      )
    )
  )

  ;; CHECK:      (func $test-nulls (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref null $struct))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.cast_static $struct
  ;; CHECK-NEXT:      (block (result (ref null $struct))
  ;; CHECK-NEXT:       (drop
  ;; CHECK-NEXT:        (select (result (ref null $struct))
  ;; CHECK-NEXT:         (ref.null $struct)
  ;; CHECK-NEXT:         (ref.null $struct)
  ;; CHECK-NEXT:         (call $import)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:       (ref.null $struct)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref null $struct))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (ref.cast_static $struct
  ;; CHECK-NEXT:      (select (result anyref)
  ;; CHECK-NEXT:       (ref.null $struct)
  ;; CHECK-NEXT:       (ref.func $test)
  ;; CHECK-NEXT:       (call $import)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null $struct)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (ref.cast_static $struct
  ;; CHECK-NEXT:    (select (result (ref null $struct))
  ;; CHECK-NEXT:     (ref.null $struct)
  ;; CHECK-NEXT:     (struct.new $struct
  ;; CHECK-NEXT:      (i32.const 6)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (call $import)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test-nulls
    ;; Only a null can flow through the cast, which we can infer for the value
    ;; of the cast.
    (drop
      (ref.cast_static $struct
        (select
          (ref.null $struct)
          (ref.null $struct)
          (call $import)
        )
      )
    )
    ;; A null or a func will reach the cast; only the null can actually pass
    ;; through (a func would fail the cast). Given that, we can infer a null for
    ;; the value of the cast.
    (drop
      (ref.cast_static $struct
        (select
          (ref.null $struct)
          (ref.func $test)
          (call $import)
        )
      )
    )
    ;; A null or a $struct may arrive, and so we cannot do anything here.
    (drop
      (ref.cast_static $struct
        (select
          (ref.null $struct)
          (struct.new $struct
            (i32.const 6)
          )
          (call $import)
        )
      )
    )
  )
)

(module
  (type $A (struct_subtype (field i32) data))
  (type $B (struct_subtype (ref $A) data))
  (type $C (struct_subtype (ref $B) data))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (i32.const 42)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; Test nested struct.get operations. We can optimize all this.
    (drop
      (struct.get $A 0
        (struct.get $B 0
          (struct.get $C 0
            (struct.new $C
              (struct.new $B
                (struct.new $A
                  (i32.const 42)
                )
              )
            )
          )
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct_subtype (field i32) data))
  (type $A (struct_subtype (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field (ref $A)) data))
  (type $B (struct_subtype (ref $A) data))
  ;; CHECK:      (type $C (struct_subtype (field (ref $B)) data))
  (type $C (struct_subtype (ref $B) data))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (struct.get $A 0
  ;; CHECK-NEXT:    (struct.get $B 0
  ;; CHECK-NEXT:     (struct.get $C 0
  ;; CHECK-NEXT:      (struct.new $C
  ;; CHECK-NEXT:       (struct.new $B
  ;; CHECK-NEXT:        (struct.new $A
  ;; CHECK-NEXT:         (call $import)
  ;; CHECK-NEXT:        )
  ;; CHECK-NEXT:       )
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    ;; As above, but now call an import for the i32; we cannot optimize.
    (drop
      (struct.get $A 0
        (struct.get $B 0
          (struct.get $C 0
            (struct.new $C
              (struct.new $B
                (struct.new $A
                  (call $import)
                )
              )
            )
          )
        )
      )
    )
  )
)

;; ref.as* test.
(module
  ;; CHECK:      (type $A (struct_subtype (field i32) data))
  (type $A (struct_subtype (field i32) data))
  ;; CHECK:      (type $B (struct_subtype (field i32) (field f64) $A))
  (type $B (struct_subtype (field i32) (field f64) $A))

  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $none_=>_ref|$B| (func_subtype (result (ref $B)) func))

  ;; CHECK:      (import "a" "b" (func $import (result i32)))
  (import "a" "b" (func $import (result i32)))

  ;; CHECK:      (func $foo (type $none_=>_ref|$B|) (result (ref $B))
  ;; CHECK-NEXT:  (local $A (ref null $A))
  ;; CHECK-NEXT:  (ref.cast_static $B
  ;; CHECK-NEXT:   (ref.as_non_null
  ;; CHECK-NEXT:    (local.tee $A
  ;; CHECK-NEXT:     (struct.new $B
  ;; CHECK-NEXT:      (i32.const 42)
  ;; CHECK-NEXT:      (f64.const 13.37)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $foo (result (ref $B))
    (local $A (ref null $A))
    (ref.cast_static $B ;; if it is $A, this will look like it traps (but it
                        ;; should not trap)
      (ref.as_non_null ;; should be $B based on the child's *contents*, not type
        (local.tee $A ;; flows out a $B, but has type $A
          (struct.new $B ;; returns a $B
            (i32.const 42)
            (f64.const 13.37)
          )
        )
      )
    )
  )
)

(module
  ;; CHECK:      (type $A (struct_subtype (field i32) data))
  (type $A (struct_subtype (field i32) data))
  ;; CHECK:      (type $none_=>_i32 (func_subtype (result i32) func))

  ;; CHECK:      (type $B (struct_subtype (field i32) (field i32) $A))
  (type $B (struct_subtype (field i32) (field i32) $A))
  ;; CHECK:      (func $0 (type $none_=>_i32) (result i32)
  ;; CHECK-NEXT:  (local $ref (ref null $A))
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result i32)
  ;; CHECK-NEXT:    (local.set $ref
  ;; CHECK-NEXT:     (struct.new $B
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:      (i32.const 1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (block (result i32)
  ;; CHECK-NEXT:     (drop
  ;; CHECK-NEXT:      (struct.get $A 0
  ;; CHECK-NEXT:       (local.get $ref)
  ;; CHECK-NEXT:      )
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:     (i32.const 0)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (i32.const 0)
  ;; CHECK-NEXT: )
  (func $0 (result i32)
    (local $ref (ref null $A))
    (local.set $ref
      (struct.new $B
        (i32.const 0)
        (i32.const 1)
      )
    )
    ;; This struct.get has a reference of type $A, but we can infer the type
    ;; present in the reference must actually be a $B, and $B precisely - no
    ;; sub or supertypes. So we can infer a value of 0.
    ;;
    ;; A possible bug that this is a regression test for is a confusion between
    ;; the type of the content and the declared type. If we mixed them up and
    ;; thought this must be precisely an $A and not a $B then we'd emit an
    ;; unreachable here (since no $A is ever allocated).
    (struct.get $A 0
      (local.get $ref)
    )
  )
)

;; array.copy between types.
(module
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $bytes (array_subtype (mut anyref) data))
  (type $bytes (array (mut anyref)))
  ;; CHECK:      (type $chars (array_subtype (mut anyref) data))
  (type $chars (array (mut anyref)))

  ;; CHECK:      (elem declare func $test)

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $bytes (ref null $bytes))
  ;; CHECK-NEXT:  (local $chars (ref null $chars))
  ;; CHECK-NEXT:  (local.set $bytes
  ;; CHECK-NEXT:   (array.init_static $bytes
  ;; CHECK-NEXT:    (ref.func $test)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $chars
  ;; CHECK-NEXT:   (array.init_static $chars
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.copy $chars $bytes
  ;; CHECK-NEXT:   (local.get $chars)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (local.get $bytes)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $none_=>_none))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (array.get $bytes
  ;; CHECK-NEXT:      (local.get $bytes)
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.func $test)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (array.get $chars
  ;; CHECK-NEXT:      (local.get $chars)
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $bytes (ref null $bytes))
    (local $chars (ref null $chars))
    (local.set $bytes
      (array.init_static $bytes
        (ref.func $test)
      )
    )
    (local.set $chars
      (array.init_static $chars
        (ref.null any)
      )
    )
    (array.copy $chars $bytes
      (local.get $chars)
      (i32.const 0)
      (local.get $bytes)
      (i32.const 0)
      (i32.const 1)
    )
    (drop
      (array.get $bytes
        (local.get $bytes)
        (i32.const 0)
      )
    )
     (drop
      (array.get $chars
        (local.get $chars)
        (i32.const 0)
      )
    )
  )
)

;; As above, but with a copy in the wrong direction. Now $chars has no possible
;; non-null value.
(module
  ;; CHECK:      (type $none_=>_none (func_subtype func))

  ;; CHECK:      (type $bytes (array_subtype (mut anyref) data))
  (type $bytes (array (mut anyref)))
  ;; CHECK:      (type $chars (array_subtype (mut anyref) data))
  (type $chars (array (mut anyref)))

  ;; CHECK:      (elem declare func $test)

  ;; CHECK:      (func $test (type $none_=>_none)
  ;; CHECK-NEXT:  (local $bytes (ref null $bytes))
  ;; CHECK-NEXT:  (local $chars (ref null $chars))
  ;; CHECK-NEXT:  (local.set $bytes
  ;; CHECK-NEXT:   (array.init_static $bytes
  ;; CHECK-NEXT:    (ref.func $test)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $chars
  ;; CHECK-NEXT:   (array.init_static $chars
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (array.copy $bytes $chars
  ;; CHECK-NEXT:   (local.get $bytes)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (local.get $chars)
  ;; CHECK-NEXT:   (i32.const 0)
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result (ref $none_=>_none))
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (array.get $bytes
  ;; CHECK-NEXT:      (local.get $bytes)
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.func $test)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (drop
  ;; CHECK-NEXT:   (block (result anyref)
  ;; CHECK-NEXT:    (drop
  ;; CHECK-NEXT:     (array.get $chars
  ;; CHECK-NEXT:      (local.get $chars)
  ;; CHECK-NEXT:      (i32.const 0)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (ref.null any)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $test
    (local $bytes (ref null $bytes))
    (local $chars (ref null $chars))
    ;; Write something to $bytes, but just a null to $chars. But then do a copy
    ;; which means both can contain that non-null value.
    (local.set $bytes
      (array.init_static $bytes
        (ref.func $test)
      )
    )
    (local.set $chars
      (array.init_static $chars
        (ref.null any)
      )
    )
    (array.copy $bytes $chars
      (local.get $bytes)
      (i32.const 0)
      (local.get $chars)
      (i32.const 0)
      (i32.const 1)
    )
    (drop
      (array.get $bytes
        (local.get $bytes)
        (i32.const 0)
      )
    )
     (drop
      (array.get $chars
        (local.get $chars)
        (i32.const 0)
      )
    )
  )
)
