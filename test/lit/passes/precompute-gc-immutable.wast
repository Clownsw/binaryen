;; NOTE: Assertions have been generated by update_lit_checks.py and should not be edited.
;; RUN: wasm-opt %s --remove-unused-names --precompute-propagate --fuzz-exec -all -S -o - \
;; RUN:   | filecheck %s
;; RUN: wasm-opt %s --remove-unused-names --precompute-propagate --fuzz-exec -all --nominal -S -o - \
;; RUN:   | filecheck %s

(module
  ;; CHECK:      (type $struct-imm (struct (field i32)))

  ;; CHECK:      (type $struct-mut (struct (field (mut i32))))
  (type $struct-mut (struct (mut i32)))
  (type $struct-imm (struct i32))

  ;; CHECK:      (func $propagate
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (local $ref-mut (ref null $struct-mut))
  ;; CHECK-NEXT:  (local.set $ref-imm
  ;; CHECK-NEXT:   (struct.new $struct-imm
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (local.set $ref-mut
  ;; CHECK-NEXT:   (struct.new $struct-mut
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-mut 0
  ;; CHECK-NEXT:    (local.get $ref-mut)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $propagate
    (local $ref-imm (ref null $struct-imm))
    (local $ref-mut (ref null $struct-mut))
    ;; We can propagate from an immutable field of a struct created in this
    ;; function.
    (local.set $ref-imm
      (struct.new $struct-imm
        (i32.const 1)
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
    ;; But the same thing on a mutable field fails.
    (local.set $ref-mut
      (struct.new $struct-mut
        (i32.const 1)
      )
    )
    (call $helper
      (struct.get $struct-mut 0
        (local.get $ref-mut)
      )
    )
  )

  ;; CHECK:      (func $unreachable
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (local.tee $ref-imm
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (unreachable)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-imm 0
  ;; CHECK-NEXT:    (local.get $ref-imm)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $unreachable
    (local $ref-imm (ref null $struct-imm))
    ;; Test we do not error on an unreachable value.
    (local.set $ref-imm
      (struct.new $struct-imm
        (unreachable)
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $param (param $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-imm 0
  ;; CHECK-NEXT:    (local.get $ref-imm)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $param (param $ref-imm (ref null $struct-imm))
    ;; Test we ignore a param value, whose data we do not know.
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $local-null
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-imm 0
  ;; CHECK-NEXT:    (ref.null $struct-imm)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $local-null
    (local $ref-imm (ref null $struct-imm))
    ;; Test we ignore a local value that is null, whose data we do not know.
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $local-unknown (param $x i32)
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref-imm
  ;; CHECK-NEXT:    (struct.new $struct-imm
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref-imm
  ;; CHECK-NEXT:    (struct.new $struct-imm
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-imm 0
  ;; CHECK-NEXT:    (local.get $ref-imm)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $local-unknown (param $x i32)
    (local $ref-imm (ref null $struct-imm))
    ;; Do not propagate if a local has more than one possible struct.new with
    ;; different values.
    (if
      (local.get $x)
      (local.set $ref-imm
        (struct.new $struct-imm
          (i32.const 1)
        )
      )
      (local.set $ref-imm
        (struct.new $struct-imm
          (i32.const 2)
        )
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $local-unknown-ref-same-value (param $x i32)
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (local.set $ref-imm
  ;; CHECK-NEXT:    (struct.new $struct-imm
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (local.set $ref-imm
  ;; CHECK-NEXT:    (struct.new $struct-imm
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (struct.get $struct-imm 0
  ;; CHECK-NEXT:    (local.get $ref-imm)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $local-unknown-ref-same-value (param $x i32)
    (local $ref-imm (ref null $struct-imm))
    ;; As above, but the two different refs have the same value, so we can in
    ;; theory optimize. However, atm we do nothing here, as the analysis stops
    ;; when it sees it cannot propagate the local value (the ref, which has two
    ;; possible values).
    (if
      (local.get $x)
      (local.set $ref-imm
        (struct.new $struct-imm
          (i32.const 1)
        )
      )
      (local.set $ref-imm
        (struct.new $struct-imm
          (i32.const 1)
        )
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $propagate-multi-refs (param $x i32)
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (if
  ;; CHECK-NEXT:   (local.get $x)
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (local.set $ref-imm
  ;; CHECK-NEXT:     (struct.new $struct-imm
  ;; CHECK-NEXT:      (i32.const 1)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (call $helper
  ;; CHECK-NEXT:     (i32.const 1)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:   (block
  ;; CHECK-NEXT:    (local.set $ref-imm
  ;; CHECK-NEXT:     (struct.new $struct-imm
  ;; CHECK-NEXT:      (i32.const 2)
  ;; CHECK-NEXT:     )
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:    (call $helper
  ;; CHECK-NEXT:     (i32.const 2)
  ;; CHECK-NEXT:    )
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $propagate-multi-refs (param $x i32)
    (local $ref-imm (ref null $struct-imm))
    ;; Propagate more than once in a function, using the same local that is
    ;; reused.
    (if
      (local.get $x)
      (block
        (local.set $ref-imm
          (struct.new $struct-imm
            (i32.const 1)
          )
        )
        (call $helper
          (struct.get $struct-imm 0
            (local.get $ref-imm)
          )
        )
      )
      (block
        (local.set $ref-imm
          (struct.new $struct-imm
            (i32.const 2)
          )
        )
        (call $helper
          (struct.get $struct-imm 0
            (local.get $ref-imm)
          )
        )
      )
    )
  )

  ;; CHECK:      (func $propagate-multi-values (param $x i32)
  ;; CHECK-NEXT:  (local $ref-imm (ref null $struct-imm))
  ;; CHECK-NEXT:  (local.set $ref-imm
  ;; CHECK-NEXT:   (struct.new $struct-imm
  ;; CHECK-NEXT:    (i32.const 1)
  ;; CHECK-NEXT:   )
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT:  (call $helper
  ;; CHECK-NEXT:   (i32.const 1)
  ;; CHECK-NEXT:  )
  ;; CHECK-NEXT: )
  (func $propagate-multi-values (param $x i32)
    (local $ref-imm (ref null $struct-imm))
    ;; Propagate a ref's value more than once
    (local.set $ref-imm
      (struct.new $struct-imm
        (i32.const 1)
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
    (call $helper
      (struct.get $struct-imm 0
        (local.get $ref-imm)
      )
    )
  )

  ;; CHECK:      (func $helper (param $0 i32)
  ;; CHECK-NEXT:  (nop)
  ;; CHECK-NEXT: )
  (func $helper (param i32))

  ;; TODO layered
)
