;; NOTE: Assertions have been generated by update_lit_checks.py --output=fuzz-exec and should not be edited.

;; RUN: wasm-opt %s -all --coalesce-locals --optimize-instructions --fuzz-exec -q -o /dev/null 2>&1 | filecheck %s

;; The sequence of passes here will do the following:
;;
;;  * coalesce-locals will remove the local.set. That does not reach any
;;    local.get due to the unreachable, so it is dead.
;;  * optimize-instructions will reorder the select's arms (to get rid of the
;;    i32.eqz). It looks ok to reorder them because the local.get on one arm has
;;    no side effects at all.
;;
;; After those, we execute a local.get of a non-nullable local that has no
;; local.set, which means we are reading a null, which cannot fit the type of
;; the local. Even if we make the interpreter trap on such things, it is not
;; enough here since the logging call will no longer happen (since the local.get
;; was reorderd to before the logging).

(module
  (import "fuzzing-support" "log-i32" (func $log (param i32)))

  (func $foo (export "foo") (param $i i32) (result anyref)
    (local $ref (ref func))
    (local.set $ref
      (ref.func $foo)
    )
    (select (result anyref)
      (block $trap (result anyref)
        (call $log
          (i32.const 42)
        )
        ;; We never reach the br, but its existence makes the block's type none
        ;; instead of unreachable (optimization passes may ignore such
        ;; obviously-unreachable code, so we make it less obvious this way).
        (unreachable)
        (br $trap
          (ref.func $foo)
        )
      )
      (local.get $ref)
      (i32.eqz
        (local.get $i)
      )
    )
  )
)
